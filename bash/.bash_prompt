
########################################### BASH PROMPT STUFF ############################################################
##  I adapated most of the non-powerline stuff from aaron bieber's dotfiles, found at:									##
##  https://github.com/aaronbieber/dotfiles/blob/master/configs/bashrc 													##
##########################################################################################################################

#Powerline goes first

# Check if powerline should be disabled
if [ -z "$POWERLINE_DISABLE" ]; then
	powerline_disable=false;
else
	powerline_disable="$POWERLINE_DISABLE"
fi

# This terminals don't play nice with powerline
anti_pwl="linux eterm eterm-color"
for term in $anti_pwl; do
	[ $term = $TERM ] && powerline_disable=true;
done
unset anti_pwl

if ! $powerline_disable; then
	if [ -n $POWERLINE_RUNNING ] && $POWERLINE_RUNNING; then
		return 0
	fi

	powerline_root="$(python -c 'from powerline.config import POWERLINE_ROOT; print (POWERLINE_ROOT)' 2>/dev/null)"
	if [ -z "$powerline_root" ]; then
		powerline_root="$(python2 -c 'from powerline.config import POWERLINE_ROOT; print (POWERLINE_ROOT)' 2>/dev/null)"
		if [ -z "$powerline_root" ]; then
			powerline_root="$(python3 -c 'from powerline.config import POWERLINE_ROOT; print (POWERLINE_ROOT)' 2>/dev/null)"
		fi
	fi
	if [ -n "$powerline_root" ]; then
		export POWERLINE_ROOT="$powerline_root/powerline"
		if [ -f $POWERLINE_ROOT/bindings/bash/powerline.sh ]; then
			# Actually load powerline
			. $POWERLINE_ROOT/bindings/bash/powerline.sh
			export POWERLINE_RUNNING=true
		else
			powerline_disable=true
		fi
	else
		powerline_disable=true
	fi
fi


if $powerline_disable; then
	if [ "$color_prompt" = yes ]; then

		# Reset
		Color_Off="\[\033[0m\]"       # Text Reset

		# Regular Colors
		# Find color codes with (for i in $(seq 0 255); do Color="\[\033[38;5;"$i"m\]"; printf "$i:\n$Color Lorem Ipsum $ColorOff\n"; done)
		Black="\[\033[0;30m\]"        
		Red="\[\033[0;31m\]"         
		Green="\[\033[0;32m\]"      
		Yellow="\[\033[0;33m\]"     
		Blue="\[\033[0;34m\]"      
		Purple="\[\033[0;35m\]"   
		Cyan="\[\033[0;36m\]"    
		White="\[\033[0;37m\]"  
		Grey="\[\033[38;5;8m\]"
		Magenta="\[\033[38;5;163m\]"  
		Orange="\[\033[38;5;208m\]"  
		LightBlue="\[\033[38;5;39m\]"
		LightOrange="\[\033[38;5;178m\]"
		LightGrey="\[\033[38;5;245m\]"

		# Bold
		BBlack="\[\033[1;30m\]"       
		BRed="\[\033[1;31m\]"        
		BGreen="\[\033[1;32m\]"     
		BYellow="\[\033[1;33m\]"   
		BBlue="\[\033[1;34m\]"    
		BPurple="\[\033[1;35m\]" 
		BCyan="\[\033[1;36m\]"  
		BWhite="\[\033[1;37m\]"
		BGrey="\[\033[1;38;5;8m\]"
		BMagenta="\[\033[1;38;5;163m\]"

		# Background
		On_Black="\[\033[40m\]"       
		On_Red="\[\033[41m\]"        
		On_Green="\[\033[42m\]"     
		On_Yellow="\[\033[43m\]"   
		On_Blue="\[\033[44m\]"    
		On_Purple="\[\033[45m\]" 
		On_Cyan="\[\033[46m\]"  
		On_White="\[\033[47m\]"

		# High Intensty
		IBlack="\[\033[0;90m\]"       
		IRed="\[\033[0;91m\]"        
		IGreen="\[\033[0;92m\]"     
		IYellow="\[\033[0;93m\]"   
		IBlue="\[\033[0;94m\]"    
		IPurple="\[\033[0;95m\]" 
		ICyan="\[\033[0;96m\]"  
		IWhite="\[\033[0;97m\]"

		# Bold High Intensty
		BIBlack="\[\033[1;90m\]"
		BIRed="\[\033[1;91m\]"        
		BIGreen="\[\033[1;92m\]"     
		BIYellow="\[\033[1;93m\]"   
		BIBlue="\[\033[1;94m\]"    
		BIPurple="\[\033[1;95m\]" 
		BICyan="\[\033[1;96m\]"  
		BIWhite="\[\033[1;97m\]"

		# High Intensty backgrounds
		On_IBlack="\[\033[0;100m\]"   
		On_IRed="\[\033[0;101m\]"    
		On_IGreen="\[\033[0;102m\]" 
		On_IYellow="\[\033[0;103m\]"
		On_IBlue="\[\033[0;104m\]" 
		On_IPurple="\[\033[10;95m\]"
		On_ICyan="\[\033[0;106m\]" 
		On_IWhite="\[\033[0;107m\]"

		# Various variables you might want for your PS1 prompt instead
		Time12h="\T"
		Time12a="\@"
		TimeShort="\A"
		PathFull="\w"
		PathShort="\W"
		NewLine="\n"
		Jobs="\j"

		# This PS1 snippet was adopted from code for MAC/BSD I saw from:
		# http://allancraig.net/index.php?option=com_content&view=article&id=108:ps1-export-command-for-git&catid=45:general&Itemid=96
		# I tweaked it to work on UBUNTU 11.04 & 11.10 plus made it mo' better

		pwdtail () { #returns the last 2 fields of the working directory
			pwd|awk -F/ '{nlast = NF -1;print $nlast"/"$NF}'
		}


		function prompt_command(){

			if [ $? -ne 0 ]; then
				ERRPROMPT='$? '
			else
				ERRPROMPT=""
			fi

			local GIT=""
			local PATHSHORT=`pwdtail`
			local LOAD=`uptime | sed 's/,//g' | awk '{min=NF-2;print $min}'`

			function git_status() {
				git_status_output=$(git status 2> /dev/null) || return 1

				branch_name() {
					sed -n 's/.*On branch //p' <<< "$git_status_output"
				}

				number_of_commits() {
					local branch_prefix='# Your branch is '
					local branch_suffix='by [[:digit:]]+'
					if [[ "$git_status_output" =~ ${branch_prefix}"$1".*${branch_suffix} ]]
					then
						echo ${BASH_REMATCH[0]//[^0-9]/}
					else
						echo 0 && return 1
					fi
				}

				match_against_status() {
					local pattern="$1"
					[[ "$git_status_output" =~ ${pattern} ]]
				}

				working_dir_clean() {
					match_against_status 'working tree clean' || match_against_status 'working directory clean'
				}

				local_changes() {
					local added='Changes to be committed'
					local not_added='Changes not staged for commit'
					match_against_status "$added|$not_added"
				}

				untracked_files() {
					match_against_status 'Untracked files'
				}

				dashline() {
					printf '%.0s-' {1..$1}
				}

				ahead_arrow() {
					if commits_ahead=$(number_of_commits "ahead")
					then
						echo -e "$bold$(dashline $commits_ahead)$Color_Off> $commits_ahead ahead"
					fi
				}

				behind_arrow() {
					if commits_behind=$(number_of_commits "behind")
					then
						echo "$commits_behind behind <$bold$(dashline $commits_behind)$Color_Off"
					fi
				}

				branch_part() {
					local branch_colour=""

					if $( untracked_files ); then
						branch_colour=$Red
					elif $( local_changes ); then
						branch_colour=$Orange
					elif $( working_dir_clean ); then
						branch_colour=$Green
					fi
					echo "$branch_colour$(branch_name)$Color_Off"
				}

				local behind_part=$(behind_arrow)
				local ahead_part=$(ahead_arrow)

				if [[ ! "$behind_part" && ! "$ahead_part" ]]
				then
					git_prompt="$(branch_part)"
				else
					git_prompt="$(branch_part) $behind_part|$ahead_part"
				fi

				echo -e "$White($git_prompt$White)"
			}

			function nl(){
				git_status >/dev/null
				dirs -c
				path=$(dirs)
				promptlength=$((${#USER}+${#HOSTNAME}+${#path}+${#git_prompt}))
				if [ $(($(tput cols) - $promptlength)) -lt 20 ]; then
					echo "\n"
				fi
			}

			if  [ $UID = 0 ]; then
				#For performance reasons, ignore git when logged in as root. You shouldn't be coding as root anyway.
				#export PS1=$Red$ERRPROMPT$IBlue'['$BRed'\u'$IRed'@'$BRed'\h'$IBlack' '$LightGrey$TimeShort$IBlue'] '$IYellow'\w'$Color_Off' '$(git_status)'\$ '
				export PS1=$Red$ERRPROMPT$BRed'['$BRed'\u'$IRed'@'$BRed'\h '$LightGrey$TimeShort$BRed'] '$IYellow'\w'$(nl)$Color_Off'\$ '
			else
				export PS1=$Red$ERRPROMPT$BYellow'['$BYellow'\u'$Yellow'@'$BYellow'\h'$IBlack' '$LightGrey$TimeShort$BYellow'] '$Cyan'\w'$(git_status)$(nl)$Color_Off'\$ '
			fi
		}


		PROMPT_COMMAND=( prompt_command )

	fi
fi

